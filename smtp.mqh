//+------------------------------------------------------------------+
//|                                                         smtp.mqh |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
//+------------------------------------------------------------------+
//| CSMTP - minimal SMTP client for MQL5                             |
//| Supports plain + implicit TLS (465) and AUTH LOGIN               |
//| Drop into an EA or script (not an indicator)                     |
//+------------------------------------------------------------------+
#property copyright "Generated by ChatGPT"
#property version   "1.00"

//#include <stdlib.mqh>

class CSMTP
  {
private:
   int      sock;
   bool     use_tls;            // whether connection is secure now
   bool     implicit_tls;       // whether started as TLS (port 465)
   uint     timeout_ms;

   string StringTrim(string s)
    {
      StringTrimLeft(s);
      StringTrimRight(s);
      return s;
    }
    
public:
                     CSMTP(uint timeout=30000) { sock = INVALID_HANDLE; use_tls=false; implicit_tls=false; timeout_ms=timeout; }
                    ~CSMTP() { Disconnect(); }

   bool              Connect(const string host, uint port, bool start_implicit_tls=false)
     {
      Disconnect();
      sock = SocketCreate(SOCKET_DEFAULT);
      if(sock==INVALID_HANDLE)
        {
         PrintFormat("CSMTP: SocketCreate failed (%d)",GetLastError());
         return false;
        }
      // connect (timeout in ms)
      if(!SocketConnect(sock,host,port,timeout_ms))
        {
         PrintFormat("CSMTP: SocketConnect to %s:%d failed (%d)",host,port,GetLastError());
         SocketClose(sock); sock=INVALID_HANDLE;
         return false;
        }

      implicit_tls = start_implicit_tls;
      use_tls = false;

      // if implicit TLS (port 465), we must perform TLS handshake at start
      if(implicit_tls)
        {
         if(!SocketTlsHandshake(sock,host))
           {
            PrintFormat("CSMTP: TLS handshake failed (%d)",GetLastError());
            SocketClose(sock); sock=INVALID_HANDLE;
            return false;
           }
         use_tls = true;
        }

      // read server greeting
      string resp;
      if(!ReadResponse(resp))
        {
         Print("CSMTP: failed reading greeting");
         Disconnect();
         return false;
        }
      return true;
     }

   void              Disconnect()
     {
      if(sock!=INVALID_HANDLE)
        {
         // try QUIT politely
         SendLine("QUIT");
         SocketClose(sock);
         sock = INVALID_HANDLE;
         use_tls = false;
         implicit_tls = false;
        }
     }

private:
   // send raw line + CRLF using TLS-aware send
   int               SendLine(const string line)
     {
      string data = line + "\r\n";
      // convert to bytes (UTF-8 recommended for headers/body)
      uchar b[];
      int len = StringToCharArray(data,b,0,-1,CP_UTF8); // returns # bytes
      if(len<=0) return(-1);

      if(use_tls || implicit_tls)
        {
         int sent = SocketTlsSend(sock,b,len);
         if(sent<0) PrintFormat("CSMTP: SocketTlsSend err %d",GetLastError());
         return sent;
        }
      else
        {
         int sent = SocketSend(sock,b,len);
         if(sent<0) PrintFormat("CSMTP: SocketSend err %d",GetLastError());
         return sent;
        }
     }

   // read server response (reads until we detect final line with code)
   bool              ReadResponse(string &out_response, uint max_wait_ms=30000)
     {
      out_response="";
      datetime endt = TimeCurrent() + int(max_wait_ms/1000) + 1;
      while(TimeCurrent() < endt)
        {
         uint avail = 0;
         uchar buff[];
         // check readable bytes depending on TLS or plain
         if(use_tls || implicit_tls)
            avail = SocketTlsReadAvailable(sock, buff, 0); // not used here; we will call SocketTlsRead with maxlen
         else
            avail = SocketIsReadable(sock);

         // always attempt to read (SocketRead/SocketTlsRead blocks until data or timeout)
         uchar buffer[];
         int got = -1;
         if(use_tls || implicit_tls)
            got = SocketTlsRead(sock, buffer, 4096); // blocks up to socket timeout
         else
            got = SocketRead(sock, buffer, 4096, timeout_ms);

         if(got>0)
           {
            out_response += CharArrayToString(buffer,0,got,CP_UTF8);
            // check if last line looks like "<code> <text>\r\n" where code is 3 digits and a space after -> final
            // find last CRLF
            int last_crlf = StringFind(out_response, "\r\n", 0);
            // parse by lines backwards to find final response code line
            string lines[];
            int n = StringSplit(out_response, '\n', lines);
            if(n>0)
              {
               // loop from last non-empty line back
               for(int i=n-1;i>=0;i--)
                 {
                  string l = StringTrim(lines[i]);
                  if(StringLen(l)==0) continue;
                  if(StringLen(l)>=4 && StringGetCharacter(l,3)==32) // space at pos 4? (0-based)
                    {
                     string code = StringSubstr(l,0,3);
                     if(StringToInteger(code)>0) return true;
                    }
                  // otherwise it's a continuation like "250-..."
                  break;
                 }
              }
           }
         else
           {
            // no data or error
            int err = GetLastError();
            if(err>0)
               PrintFormat("CSMTP: ReadResponse socket read returned %d err=%d",got,err);
            // give small sleep then retry until timeout
            Sleep(50);
           }
        }
      Print("CSMTP: ReadResponse timed out");
      return(false);
     }

   // helper to send a command and read response into resp. Returns true if reply code starts with expected prefix (e.g., "250")
   bool              SendCommandExpect(const string cmd, string &resp, const string expect_prefix="250")
     {
      if(SendLine(cmd) < 0) { Print("CSMTP: failed send"); return false; }
      if(!ReadResponse(resp)) { Print("CSMTP: no response for "+cmd); return false; }
      // check first three digits of response
      if(StringLen(resp) >= 3)
         return(StringSubstr(resp,0,3) == expect_prefix);
      return false;
     }

public:
   // perform EHLO/HELO and optionally STARTTLS
   bool              GreetingAndStartTLS(const string host_name)
     {
      string resp;
      // Send EHLO first
      if(!SendCommandExpect("EHLO "+host_name, resp, "250"))
        {
         // fallback to HELO
         if(!SendCommandExpect("HELO "+host_name, resp, "250")) { Print("CSMTP: EHLO/HELO failed"); return false; }
        }

      // If server supports STARTTLS and we are not implicit TLS and not already TLS, try upgrade
      if(!use_tls && !implicit_tls)
        {
         // check presence of "STARTTLS" in server response
         if(StringFind(resp, "STARTTLS")>=0)
           {
            if(!SendCommandExpect("STARTTLS", resp, "220")) { Print("CSMTP: STARTTLS not accepted"); return false; }
            // perform TLS handshake
            if(!SocketTlsHandshake(sock,host_name))
              {
               PrintFormat("CSMTP: SocketTlsHandshake failed (%d)",GetLastError());
               return false;
              }
            use_tls = true;
            // after TLS handshake, send EHLO again over TLS
            if(!SendCommandExpect("EHLO "+host_name, resp, "250")) { Print("CSMTP: EHLO after STARTTLS failed"); return false; }
           }
        }
      return true;
     }

   // AUTH LOGIN (base64 username/password)
   bool              AuthLogin(const string username, const string password)
     {
      string resp;
      if(!SendCommandExpect("AUTH LOGIN", resp, "334")) // server will ask for username
         { Print("CSMTP: AUTH LOGIN not accepted"); return false; }

      string buser = Base64Encode(username);
      if(SendLine(buser) < 0) return false;
      if(!ReadResponse(resp)) return false;
      if(StringSubstr(resp,0,3) != "334") { Print("CSMTP: username not accepted"); return false; }

      string bpass = Base64Encode(password);
      if(SendLine(bpass) < 0) return false;
      if(!ReadResponse(resp)) return false;
      if(StringSubstr(resp,0,3) != "235") { Print("CSMTP: auth failed: "+resp); return false; }
      return true;
     }

   // send a simple message (single recipient). For multiple recipients, call RcptTo multiple times.
   bool              SendMail(const string from, const string to, const string subject, const string body, bool is_html=false)
     {
      string resp;
      if(!SendCommandExpect("MAIL FROM:<"+from+">", resp, "250")) { Print("CSMTP: MAIL FROM failed: "+resp); return false; }
      if(!SendCommandExpect("RCPT TO:<"+to+">", resp, "250") && !SendCommandExpect("RCPT TO:<"+to+">", resp, "251")) { Print("CSMTP: RCPT failed: "+resp); return false; }

      if(!SendCommandExpect("DATA", resp, "354")) { Print("CSMTP: DATA not accepted: "+resp); return false; }

      // build minimal headers
      string mime = "From: "+from+"\r\n";
      mime += "To: "+to+"\r\n";
      mime += "Subject: "+subject+"\r\n";
      mime += "MIME-Version: 1.0\r\n";
      if(is_html)
         mime += "Content-Type: text/html; charset=utf-8\r\n";
      else
         mime += "Content-Type: text/plain; charset=utf-8\r\n";
      mime += "Content-Transfer-Encoding: 8bit\r\n\r\n";
      mime += body;
      // terminate DATA with CRLF.CRLF
      if(SendLine(mime) < 0) { Print("CSMTP: failed to send mime body"); return false; }
      // send the terminating dot on its own line
      if(SendLine(".") < 0) { Print("CSMTP: failed to send terminating dot"); return false; }

      if(!ReadResponse(resp)) return false;
      if(StringSubstr(resp,0,3) != "250") { Print("CSMTP: DATA not accepted after send: "+resp); return false; }
      return true;
     }

   // Convenience: single-shot send (connect, EHLO/STARTTLS, auth, send, quit)
   bool              SendMessageFull(const string host, uint port, const string host_name,
                                     const string username, const string password,
                                     const string from, const string to, const string subject, const string body,
                                     bool useImplicitTLS=false, bool is_html=false)
     {
      if(!Connect(host,port,useImplicitTLS)) return false;
      if(!GreetingAndStartTLS(host_name)) { Disconnect(); return false; }
      if(StringLen(username)>0)
        {
         if(!AuthLogin(username,password)) { Disconnect(); return false; }
        }
      bool ok = SendMail(from,to,subject,body,is_html);
      SendLine("QUIT");
      Disconnect();
      return ok;
     }

   // Base64 encoder used for AUTH LOGIN (simple, works for ASCII passwords)
   static string    Base64Encode(const string s)
     {
      uchar in[];
      int inlen = StringToCharArray(s,in,0,-1,CP_UTF8);
      if(inlen<=0) return("");

      const string table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      string out="";
      int i=0;
      while(i < inlen)
        {
         int b1 = in[i++];
         int b2 = (i<inlen)?in[i++]:-1;
         int b3 = (i<inlen)?in[i++]:-1;

         int triple = (b1<<16) | ((b2>0?b2:0)<<8) | (b3>0?b3:0);

         out += StringSubstr(table, (triple>>18)&0x3F, 1);
         out += StringSubstr(table, (triple>>12)&0x3F, 1);
         if(b2==-1) out += "="; else out += StringSubstr(table, (triple>>6)&0x3F, 1);
         if(b3==-1) out += "="; else out += StringSubstr(table, triple&0x3F, 1);
        }
      return out;
     }
  };